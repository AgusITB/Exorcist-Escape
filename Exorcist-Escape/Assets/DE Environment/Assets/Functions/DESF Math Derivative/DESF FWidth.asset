%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 78b2425a2284af743826c689403a4924, type: 3}
  m_Name: DESF FWidth
  m_EditorClassIdentifier: 
  m_functionInfo: "// Made with Amplify Shader Editor v1.9.2.2\n// Available at the
    Unity Asset Store - http://u3d.as/y3X \n/*ASEBEGIN\nVersion=19202\nNode;AmplifyShaderEditor.CommentaryNode;31;-704,848;Inherit;False;1229.294;442.7413;Generating
    Face Normals;9;29;26;25;24;23;22;30;28;27;;0.1226415,0.1226415,0.1226415,1;0;0\nNode;AmplifyShaderEditor.CommentaryNode;19;-704,256;Inherit;False;1219.211;516.0096;DDX
    DDY;4;17;16;20;21;;0,0,0,1;0;0\nNode;AmplifyShaderEditor.CommentaryNode;18;-704,-32;Inherit;False;612;259;Safe
    Mode;4;8;3;10;1;;0,0,0,1;0;0\nNode;AmplifyShaderEditor.CommentaryNode;14;-717.7518,-576;Inherit;False;1234.75;524.352;FWidth
    Node;3;13;12;11;;0,0,0,1;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;11;-474.5115,-352;Inherit;False;943.3171;231.1232;Derivative;;0,0,0,1;The
    FWidth, DDXY and the DDX & DDY functions give you information about how much
    a value change between one pixel and the next.$$--- DDY returns the horizontal
    change in left pixel value from the left subtracted from the right $--- DDX returns
    the vertical change in top pixels value from the top subtracted from the bottom
    $--- FWidth returns the abs value of DDY and DDX added together and is native
    to the HLSL compiler$--- DDXY does the same as FWidth however skips the abs value
    and Unity simply adds the results of DDY and DDX together$$ Note Unity shader
    graph does not have a FWidth node $;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;12;-496,-528;Inherit;False;972.4392;153.0162;;;0,0,0,1;The
    Fwith node outputs the absolute value of the partial derivatives of the specified
    Input value or, in case of vectors, each component value of the input vector.
    $$In other words it sums the absolute values of its partial derivatives of the
    Input value both in horizontal and vertical window space abs(ddx(Input)) + abs(ddy(Input)).$;0;0\nNode;AmplifyShaderEditor.FWidthOpNode;13;-656,-528;Inherit;True;1;0;FLOAT2;0,0;False;1;FLOAT2;0\nNode;AmplifyShaderEditor.StickyNoteNode;15;-1200,-576;Inherit;False;424;177.1964;Reference
    Implementation;;0,0,0,1;fmod for float3 vectors could be implemented this way:$$float3
    fwidth(float3 a)${$  return abs(ddx(a)) + abs(ddy(a))@$};0;0\nNode;AmplifyShaderEditor.FWidthOpNode;1;-656,16;Inherit;False;1;0;FLOAT2;0,0;False;1;FLOAT2;0\nNode;AmplifyShaderEditor.FunctionSwitch;3;-352,16;Inherit;False;Safe
    Mode;True;1;2;-1;;;Object;-1;10;0;FLOAT2;0,0;False;1;FLOAT2;0,0;False;2;FLOAT;0;False;3;FLOAT;0;False;4;FLOAT;0;False;5;FLOAT;0;False;6;FLOAT;0;False;7;FLOAT;0;False;8;FLOAT;0;False;9;FLOAT;0;False;1;FLOAT2;0\nNode;AmplifyShaderEditor.SimpleMaxOpNode;8;-480,80;Inherit;False;2;0;FLOAT2;0,0;False;1;FLOAT;0;False;1;FLOAT2;0\nNode;AmplifyShaderEditor.RangedFloatNode;10;-656,112;Inherit;False;Constant;_Float0;Float
    0;0;0;Create;True;0;0;0;False;0;False;0.01;0;0;0;0;1;FLOAT;0\nNode;AmplifyShaderEditor.DdxOpNode;16;-656,304;Inherit;True;1;0;FLOAT;0;False;1;FLOAT;0\nNode;AmplifyShaderEditor.DdyOpNode;17;-656,528;Inherit;True;1;0;FLOAT;0;False;1;FLOAT;0\nNode;AmplifyShaderEditor.StickyNoteNode;20;-464,304;Inherit;False;338.6371;179.3334;DDX
    Node;;0,0,0,1;The DDX Node allows you to find the difference (the partial derivative)
    between data in the current pixel and data in the next pixel over to the right
    in screen space.$$This node only works in the fragment stage.;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;21;-464,544;Inherit;False;338.6371;179.3334;DDY
    Node;;0,0,0,1;The DDY Node allows you to find the difference (the partial derivative)
    between data in the current pixel and data in the next pixel above in screen
    space.$$This node only works in the fragment stage.;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;27;-640,1056;Inherit;False;306;118;;;0,0,0,1;DDX
    and DDY find the difference between the position of the current pixel and the
    one next to it - horizontally (for DDX), and vertically (for DDY). ;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;28;-256,1088;Inherit;False;362;154;;;0,0,0,1;Doing
    a cross product between those two slope vectors creates a surface normal.  Notice
    that it's faceted.  This is because we're not using the smoothed vertex normals,
    but instead, we're generating the normals purely from the shape of the geometry.;0;0\nNode;AmplifyShaderEditor.StickyNoteNode;30;144,1120;Inherit;False;235;142;;;0,0,0,1;The
    results are in World space, so we have to transform to Tangent space if we want
    to plug the result into the Master Stack.;0;0\nNode;AmplifyShaderEditor.WorldPosInputsNode;22;-640,896;Inherit;False;0;4;FLOAT3;0;FLOAT;1;FLOAT;2;FLOAT;3\nNode;AmplifyShaderEditor.DdxOpNode;23;-432,896;Inherit;False;1;0;FLOAT3;0,0,0;False;1;FLOAT3;0\nNode;AmplifyShaderEditor.DdyOpNode;24;-432,976;Inherit;False;1;0;FLOAT3;0,0,0;False;1;FLOAT3;0\nNode;AmplifyShaderEditor.CrossProductOpNode;25;-288,896;Inherit;False;2;0;FLOAT3;0,0,0;False;1;FLOAT3;0,0,0;False;1;FLOAT3;0\nNode;AmplifyShaderEditor.NormalizeNode;26;-112,896;Inherit;True;False;1;0;FLOAT3;0,0,0;False;1;FLOAT3;0\nNode;AmplifyShaderEditor.TransformDirectionNode;29;160,896;Inherit;True;World;Tangent;False;Fast;False;1;0;FLOAT3;0,0,0;False;4;FLOAT3;0;FLOAT;1;FLOAT;2;FLOAT;3\nNode;AmplifyShaderEditor.FunctionOutput;0;-640,-288;Inherit;False;True;-1;Output;0;False;1;0;FLOAT2;0,0;False;1;FLOAT2;0\nWireConnection;3;0;1;0\nWireConnection;3;1;8;0\nWireConnection;8;0;1;0\nWireConnection;8;1;10;0\nWireConnection;23;0;22;0\nWireConnection;24;0;22;0\nWireConnection;25;0;23;0\nWireConnection;25;1;24;0\nWireConnection;26;0;25;0\nWireConnection;29;0;26;0\nASEEND*/\n//CHKSM=8B7A504833E7DB26A4653CEDFA32B1DE999E43FE"
  m_functionName: 
  m_description: 'FWidth Node


    Teaching Sample

'
  m_additionalIncludes:
    m_additionalIncludes: []
    m_outsideIncludes: []
  m_additionalPragmas:
    m_additionalPragmas: []
    m_outsidePragmas: []
  m_additionalDirectives:
    m_validData: 0
    m_isDirty: 0
    m_moduleName: ' Additional Directives'
    m_independentModule: 1
    m_customEdited: 0
    m_additionalDirectives: []
    m_shaderFunctionDirectives: []
    m_nativeDirectives: []
    m_nativeDirectivesIndex: -1
    m_nativeDirectivesFoldout: 0
    m_directivesSaveItems: []
  m_nodeCategory: 0
  m_headerStyle: 2
  m_headerColor: {r: 0.19215687, g: 0.25882354, b: 0.3254902, a: 1}
  m_customNodeCategory: DESF Math Derivative
  m_previewPosition: 0
  m_hidden: 0
  m_url: 
